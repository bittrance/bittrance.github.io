<!doctype html><html lang=en-us><head><title>VPN-less access to Azure Private vnet // Bittrance blog</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.146.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Bittrance"><meta name=description content><link rel=stylesheet href=/css/main.min.774cf882ef06d0b1c681097dcf3ac9335cbbb4e5e68707e3dcdb4d356db2d3a8.css><meta name=twitter:card content="summary"><meta name=twitter:title content="VPN-less access to Azure Private vnet"><meta name=twitter:description content="A simple method to get access to private networks on private clouds."><meta property="og:url" content="https://bittrance.github.io/posts/vpnless-access-to-azure-private-vnet/"><meta property="og:site_name" content="Bittrance blog"><meta property="og:title" content="VPN-less access to Azure Private vnet"><meta property="og:description" content="A simple method to get access to private networks on private clouds."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-29T13:49:00+02:00"><meta property="article:modified_time" content="2021-09-29T13:49:00+02:00"></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/bittrance.jpeg alt=Bittrance></a>
<span class=app-header-title>Bittrance blog</span><p>DevOps blog with focus on distributed systems and resiliency engineering.</p><div class=app-header-social><a href=https://github.com/bittrance target=_blank rel="noreferrer noopener me"><svg class="icon icon-github" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>VPN-less access to Azure Private vnet</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Sep 29, 2021</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</div></div></header><div class=post-content><p>Accessing cloud resources that are not exposed to the Internet is a constant headache. Neither Azure nor AWS have a VPN solution that can be attached to any private subnet and just works. Traditionally, you would spin up a VM with openssh and connect it to some public subnet as well as the relevant private subnet, punch a hole in the network policy and use SSH tunnelling. Forgotten &ldquo;bastion&rdquo; VMs will put you on the shortlist to &ldquo;win&rdquo; the next security audit. Is there no way avoid this embarrassment?</p><p>There is a new class of &ldquo;VPN-less&rdquo; systems you can use. Have a look at <a href=https://www.boundaryproject.io/>Boundary</a>, <a href=https://goteleport.com/>Teleport</a> or <a href=https://www.strongdm.com/>StrongDM</a>. However, it requires some effort to introduce one of these services into existing infrastructure. If your need is temporary, the cost is probably bigger than the benefit.</p><p>With Azure, there is a method that supports some tunnelling scenarios with simpler setup <em>and</em> better security. There is a somewhat obscure service called <a href=https://docs.microsoft.com/en-us/azure/azure-relay/relay-what-is-it>Azure Relay</a> which has grown out of Azure Service Bus. Its &ldquo;Hybrid connection&rdquo; mode allows two parties to establish a point-to-point tunnel by connecting to Azure Relay from each end, thus allowing both ends to traverse NAT and avoid inbound firewalling. Using this service, you can establish a connection <em>from</em> a private vnet to Azure Relay and thus forward a tunnel into the private vnet without directly involving an Internet-facing vnet.</p><p>In order to facilitate using Hybrid connections for tunnelling, Azure has published the <a href=https://github.com/Azure/azure-relay-bridge>Azure Relay Bridge</a>. It is a command line tool called azbridge, which can act as both client and forwarder with Azure Relay. azbridge can be run with either -L or -R (inspired by openssh flags with similar meaning). <code>azbridge -L</code> opens a local TCP listener socket and forwards TCP connections to a Hybrid connection, while <code>azbridge -R</code> receives traffic from a Hybrid connection and forwards onto some remote target host/port pair. Connections are authenticated with a SAS URI.</p><table><thead><tr><th style=text-align:center><img src=/vpnless-access-to-azure-private-vnet/azure-relay.drawio.png alt="Azure Relay tunnelling across two outbound connections"></th></tr></thead><tbody><tr><td style=text-align:center><em>Azure Relay tunnelling across two outbound connections</em></td></tr></tbody></table><p>This method has several advantages over the traditional ssh bastion host:</p><ul><li>few assumptions: any Docker-enabled host which can reach the Internet can reach any private vnet,</li><li>least privilege: precise control over both who can connect and what they can connect to, and</li><li>auditable: inspecting a hybrid connection tells us both who can connect and what they can connect to.</li></ul><p>In order to make deploying this tool simple, I have taken the liberty to publish this tool to Docker Hub as <a href=https://hub.docker.com/repository/docker/bittrance/azbridge>bittrance/azbridge</a>.</p><h2 id=demonstration>Demonstration</h2><p>For easy cleanup, we create a Resource Group for our demonstration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az group create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --location westeurope
</span></span></code></pre></div><p>Here is the private vnet that we want to access. The second command gives you the VNET_ID that we need when we set up further resources.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az network vnet create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name vnet-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --address-prefixes 10.0.0.0/16
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>az network vnet show <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name vnet-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --query id <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --output tsv
</span></span></code></pre></div><h3 id=example-target-resource>Example target resource</h3><p>For the sake of this demonstration, we can set up a simple echo server which serves as our &ldquo;target resource&rdquo; in the picture above. The goal is to be able to connect to this container despite it having no public IP.</p><p>In order to be able to create containers on a vnet, ACI needs to have a subnet delegated to it. Such a subnet can only contain containers. For more information, see ACI <a href=https://docs.microsoft.com/en-us/azure/container-instances/container-instances-virtual-network-concepts>Virtual Networking Scenarios</a> documentation. In this example, we allow ACI to create the subnet for itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az container create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --image hashicorp/http-echo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --command-line <span style=color:#e6db74>&#39;/http-echo -listen=:8080 -text=&#34;Hello World&#34;&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --ports <span style=color:#ae81ff>8080</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name aci-echo-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --vnet VNET_ID <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --subnet snet-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --subnet-address-prefix 10.0.0.0/24
</span></span></code></pre></div><h3 id=setting-up-a-relay>Setting up a relay</h3><p>First, we create a Relay namespace. It acts as a grouping resource for our forwarders. Each forwarder is represented by a hybrid connection, which is basically just a name that allows connecting and forwarding parties to meet.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az relay namespace create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name relns-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --location westeurope
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>az relay hyco create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --namespace-name relns-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name hyco-echo-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --requires-client-authorization
</span></span></code></pre></div><p>In order to authenticate with the with the service, we need to create an SAS policy. For the sake of this demonstration, we create a single policy and corresponding key which can both send (i.e. connect) and listen (i.e. forward). If you want to be a bit more security-conscious, you can create different rules for listening and sending. The list command will output a string starting with <code>SAS_POLICY</code> which we will use below to authenticate our tunnels.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az relay hyco authorization-rule create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --namespace-name relns-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --hybrid-connection-name hyco-echo-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name sas-echo-server-bittrance <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --rights Listen Send
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>az relay hyco authorization-rule keys list <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --namespace-name relns-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --hybrid-connection-name hyco-echo-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name sas-echo-server-bittrance <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --query primaryConnectionString <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --output tsv
</span></span></code></pre></div><p>With this, we can now spin up an Azure Container instance that attaches to the vnet and forwards traffic to the target resource. ACI appears not to want to auto-create more than one subnet for itself in a particular vnet, so in this demonstration we put the bridge on the same subnet as the echo server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az container create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --resource-group rg-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --image bittrance/azbridge:latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --command-line <span style=color:#e6db74>&#39;/app/azbridge -R hyco-echo-server:10.0.0.1:8080 -x SAS_POLICY&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name aci-access-bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --vnet VNET_ID <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --subnet snet-access-bridge
</span></span></code></pre></div><h3 id=testing-the-relay>Testing the relay</h3><p>We can now use Docker to establish a connection with the Hybrid connection and thence onto the target service. This example binds port 8080 on the local machine and forwards it to the echo server:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -p 127.0.0.1:8080:8080 --rm -it bittrance/azbridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -L 0.0.0.0:8080:hyco-echo-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -x <span style=color:#e6db74>&#39;SAS_POLICY&#39;</span>
</span></span></code></pre></div><p>Once azbridge has acquired a tunnel, we can test our access to the target resource.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -v http://localhost:8080/
</span></span></code></pre></div><p>If everything works, you will see something like this:</p><pre tabindex=0><code>*   Trying 127.0.0.1:8080...
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.78.0
&gt; Accept: */*
&gt;
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 200 OK
&lt; X-App-Name: http-echo
&lt; X-App-Version: 0.2.3
&lt; Date: Wed, 29 Sep 2021 11:29:42 GMT
&lt; Content-Length: 12
&lt; Content-Type: text/plain; charset=utf-8
&lt;
Hello World
* Connection #0 to host localhost left intact
</code></pre><h2 id=teardown>Teardown</h2><p>Don&rsquo;t forget to tear down your resources.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>az group delete --name rg-access-bridge
</span></span></code></pre></div><h2 id=finally>Finally</h2><p>Please note that a Hybrid connection costs about USD 13/month and each listener costs another USD 10/month and that traffic above 5 GB is charged at a steep USD 1/GB. For most cases, these numbers are small, but if you are really shoestring, they may be a concern and you may want to create and tear down the setup between usage.</p><p>Latency is not great with this setup. After all, there may be upwards of six different TCP sessions involved (client -> Docker proxy -> azbridge -L -> Azure Relay inbound -> Azure Relay outbound -> (Docker proxy -> ?) azbridge -R -> Service). Massive data transfers and highly interactive web apps are likely to suffer accordingly. Still, as a service hatch, it works quite well.</p><p>With this setup, certificates will not be valid since the remote end will claim to be whatever service we are trying to connect to, but on the local machine, we will of course connect to localhost. Your driver/lib/browser will have to be persuaded not to verify the certificate.</p><p>Also, while this procedure is most useful on Azure, there is nothing to stop you from using it with any other cloud provider or even on-premise access. Wherever you can run <code>azbridge -R</code>, this process should be usable.</p></div><div class=post-footer></div></article></main></body></html>