<!doctype html><html lang=en-us><head><title>Extending Our Tekton Pipeline // Bittrance blog</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.125.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Bittrance"><meta name=description content><link rel=stylesheet href=https://bittrance.github.io/css/main.min.4639652e53d7c522a16b943011b619fd746bc6fb5fb4b8d6ced8387535c7b364.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Extending Our Tekton Pipeline"><meta name=twitter:description content="This blog post continues my exploration of Tekton. In the first blog post we created a simple pipeline that ran our frontend tests. In this blog post we will show how to set up pods to support our tests. This also serves as a sketch of how to interact with Kubernetes in general."><meta property="og:url" content="https://bittrance.github.io/posts/extending-our-tekton-pipeline/"><meta property="og:site_name" content="Bittrance blog"><meta property="og:title" content="Extending Our Tekton Pipeline"><meta property="og:description" content="This blog post continues my exploration of Tekton. In the first blog post we created a simple pipeline that ran our frontend tests. In this blog post we will show how to set up pods to support our tests. This also serves as a sketch of how to interact with Kubernetes in general."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-04T14:31:00+02:00"><meta property="article:modified_time" content="2021-05-04T14:31:00+02:00"></head><body><header class=app-header><a href=https://bittrance.github.io/><img class=app-header-avatar src=/bittrance.jpeg alt=Bittrance></a><h1>Bittrance blog</h1><p>DevOps blog with focus on distributed systems and resiliency engineering.</p><div class=app-header-social><a href=https://github.com/bittrance target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Extending Our Tekton Pipeline</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
May 4, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
7 min read</div></div></header><div class=post-content><p>This blog post continues my exploration of <a href=https://tekton.dev>Tekton</a>. In the <a href=/posts/extending-our-tekton-pipeline/>first blog post</a> we created a simple pipeline that ran our frontend tests. In this blog post I will show how to set up pods to support our tests. This also serves as a sketch of how to interact with Kubernetes in general.</p><h2 id=recap>Recap</h2><p>We need a non-trivial project so that we can explore difficulties that tend to arise when writing build pipelines. These blog posts will try to recreate the <a href=https://github.com/bittrance/striv/blob/cfac501a45db4c58ae526a3e58242c6245305624/.github/workflows/default-test.yml>striv master pipeline</a>. Striv is a typical webapp with a Vue-based frontend and a Python-based backend which keeps its state in MySQL or Postgres - in other words a bog-standard single-page application (SPA). Its main Github action contains the following steps:</p><ol><li>Run node unit tests for the frontend (<code>npm run test:unit</code>)</li><li>Run python unit and integration tests for the backend (<code>pytest</code>)</li><li>Build and push a Docker image (<code>docker build</code> and <code>docker push</code>)</li></ol><p>We already did step 1, and now it is time for step 2.</p><h2 id=running-backend-unit-tests>Running backend unit tests</h2><p>The Striv backend tests are mostly straight-forward unit tests, but includes some tests that test the interaction with supported databases, namely MySQL and Postgres. It does not, however provide <a href=https://docs.pytest.org/en/stable/mark.html>pytest &ldquo;marks&rdquo;</a> to select only the unit test. Instead, there is a JSON config file called <code>testing-databases.conf</code> which controls what databases are tested. Tekton has a standard task <a href=https://hub.tekton.dev/tekton/task/write-file>write-file</a> that allows us to write an arbitrary file to disk:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/write-file/0.1/write-file.yaml
</span></span></code></pre></div><p>Writing a simple &ldquo;unit test only&rdquo; <code>testing-databases.conf</code> looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>write-testing-databases-conf</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>runAfter</span>: [<span style=color:#ae81ff>checkout]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>taskRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>write-file</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Task</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>workspaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>output</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>workspace</span>: <span style=color:#ae81ff>striv-workspace</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>params</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>path</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#ae81ff>testing-databases.json</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>contents</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#39;[[&#34;sqlite&#34;, {&#34;database&#34;: &#34;:memory:&#34;}]]&#39;</span>
</span></span></code></pre></div><p>We can now use the standard <a href=https://hub.tekton.dev/tekton/task/pytest>pytest task</a> to run our tests.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/pytest/0.1/pytest.yaml
</span></span></code></pre></div><p>The actual pytest task is quite straight-forward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-backend</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>runAfter</span>: [<span style=color:#ae81ff>write-testing-databases-conf]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>taskRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pytest</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Task</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>workspaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>source</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>workspace</span>: <span style=color:#ae81ff>striv-workspace</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>params</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>PYTHON</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;3.7&#34;</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>REQUIREMENTS_FILE</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#ae81ff>requirements-dev.txt</span>
</span></span></code></pre></div><h2 id=integration-tests>Integration tests</h2><p>However, we do want to run those MySQL and Postgres tests! So how are we going to get databases up? There are at least two different strategies to provide supporting resources to your tests:</p><ol><li>Use sidecars. Tekton has explicit support for running sidecars to Tasks.</li><li>Deploy Kubernetes resources (i.e. pods) to support our integration tests.</li></ol><p>Sidecars sound tempting, but has two problems. First, they can only be used by task definitions and not from a pipeline. That would mean that we could not use the standard pytest task above, but would have to copy it and define our own task that includes the sidecars. Second, we are likely to run into readiness issues and would have to include an explicit script step to wait for the database sockets to become available. These issues are surmountable and had I been at work, I would probably have taken this route.</p><p>But this is a blog post, and we are here to learn Tekton. Deploying a set of Kubernetes resources to provide those databases is a much more generally applicable technique, so let&rsquo;s see what it takes to do that!</p><h3 id=deploying-kubernetes-resources>Deploying Kubernetes resources</h3><p>We can use the standard <a href=https://hub.tekton.dev/tekton/task/kubernetes-actions>kubernetes-actions</a> task to deploy resources to a Kubernetes cluster.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/kubernetes-actions/0.2/kubernetes-actions.yaml
</span></span></code></pre></div><p>For the sake of simplicity, I&rsquo;m inlining the manifest in the task. I could equally set it up as a ConfigMap or mount the <code>striv-workspace</code> and reference a file from the GitHub repository (though we would have had to resort to e.g. <code>sed</code> to inject parameters).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>deploy-test-dependencies</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>taskRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubernetes-actions</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Task</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>params</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>script</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kubectl apply -f - &lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kind: Service
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            metadata:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              # Unique name so it won&#39;t collide with concurrent runs
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              name: mysql-$(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              labels:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                # So we can delete both this and Postgres
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                test-dependencies: $(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            spec:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              ports:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                - name: mysql
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  port: 3306
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  targetPort: mysql
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              selector:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                mysql: $(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            ---
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            metadata:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              name: mysql-$(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              labels:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                # So we can delete both this and Postgres
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                test-dependencies: $(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                # So the mysql service can find only this pod (and not Postgres)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                mysql: $(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            spec:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              containers:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                - name: mysql
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  image: mysql:5.6
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  ports:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    - name: mysql
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                      containerPort: 3306
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  env:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    - name: MYSQL_ROOT_PASSWORD
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                      value: $(context.pipelineRun.uid)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    - name: MYSQL_DATABASE
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                      value: striv_test
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kubectl wait pods -l mysql=$(context.pipelineRun.uid) --timeout=30s --for condition=ready</span>            
</span></span></code></pre></div><p>Note that this task has no <code>runAfter</code> key. Test resource creation will begin immediately when the pipeline is run, which means that it is very likely that they will be ready by the time we run the backend tests (checking out the GitHub repository and then installing the Pip dependencies takes well over a minute). Likely enough that we can ignore the issue of checking for readiness. One reason for not addressing this issue is that the standard MySQL container restarts mysql once as part of its setup. This means that this check gets quite complicated since even succesfully connecting to port 3306 will not guarantee that MySQL is ready to serve our requests.</p><p>A very similar entry will be needed for Postrgres 11, but that is left as an exercise to the reader.</p><p>The configuration file injected by <code>write-testing-databases-conf</code> will need updating to include MySQL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>write-testing-databases-conf</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>runAfter</span>: [<span style=color:#ae81ff>checkout]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>taskRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>write-file</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Task</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>workspaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>output</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>workspace</span>: <span style=color:#ae81ff>striv-workspace</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>params</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>path</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#ae81ff>testing-databases.json</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>contents</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            [
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              [&#34;sqlite&#34;, {&#34;database&#34;: &#34;:memory:&#34;}],
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              [
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                &#34;mysql&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  &#34;user&#34;: &#34;root&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  &#34;password&#34;: &#34;$(context.pipelineRun.uid)&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  &#34;host&#34;: &#34;mysql-$(context.pipelineRun.uid)&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  &#34;database&#34;: &#34;striv_test&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                  &#34;create_database&#34;: true
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              ]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            ]</span>            
</span></span></code></pre></div><h3 id=tearing-down-the-testing-resources>Tearing down the testing resources</h3><p>Once the test run is finished, we want to drop the database pods again. We could just add a normal task with <code>runAfter: ["test-backend"]</code>, but that might trip us up in the future when we add more tasks to our pipeline. Better to drop them as the very last activity (plus we get to explore another Tekton feature). Tekton provides a <a href=https://tekton.dev/docs/pipelines/pipelines/#adding-finally-to-the-pipeline>finally</a> section for this scenario where you can add tasks that should be run at the end of the pipeline, regardless of success.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  <span style=color:#f92672>finally</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>delete-test-dependencies</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>taskRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubernetes-actions</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Task</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>params</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>script</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kubectl delete pods -l test-dependencies=$(context.pipelineRun.uid) --timeout=30s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            kubectl delete services -l test-dependencies=$(context.pipelineRun.uid) --timeout=30s</span>            
</span></span></code></pre></div><h2 id=running-the-pipeline>Running the pipeline</h2><p>If we were to run the pipeline now, the <code>deploy-test-dependencies</code> task would fail with a &ldquo;Forbidden&rdquo; error message, because it does not have permission to interact with our Kubernetes cluster. Tekton pipelines normally use the &ldquo;default&rdquo; service account, which has very few permissions. We can assign a different account, either to the whole pipeline, or to an individual task. This pipeline draws code from several different sources (e.g. Docker Hub, GitHub, PyPI and npmjs.org) so there is plenty opportunity to sneak in malevolent code. It therefore makes sense to grant permissions only to the necessary tasks.</p><p>First, we need to create this service account and give it some permissions. For the sake of completeness, we create a role for it as well; in a production scenario, you would probably have a reasonalbe group or role available already.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceAccount</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Role</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiGroups</span>: [<span style=color:#e6db74>&#34;&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: [<span style=color:#ae81ff>pods, services]</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>verbs</span>: [<span style=color:#ae81ff>create, delete, get, list, watch]</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>RoleBinding</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span><span style=color:#f92672>subjects</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceAccount</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span><span style=color:#f92672>roleRef</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Role</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apiGroup</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io</span>
</span></span></code></pre></div><p>Finally, we need to tell Tekton that the two test dependency tasks should use this service account. This is part of the PipelineRun resource and looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>tekton.dev/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PipelineRun</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>deploy-striv-run-2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>pipelineRef</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>deploy-striv</span> <span style=color:#75715e># We want to run this pipeline</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceAccountNames</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Tasks to set up and tear down test dependencies need to use a service account</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>taskName</span>: <span style=color:#ae81ff>deploy-test-dependencies</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>serviceAccountName</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>taskName</span>: <span style=color:#ae81ff>delete-test-dependencies</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>serviceAccountName</span>: <span style=color:#ae81ff>test-dependencies-deployer</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>workspaces</span>:
</span></span><span style=display:flex><span>    - <span style=color:#75715e># This describes how to provide the workspace that the pipeline requires</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>striv-workspace</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeClaimTemplate</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span>
</span></span></code></pre></div><p>The <a href=/extending-our-tekton-pipeline/deploy-striv-extended.yaml>updated pipeline</a> is here if you want to test it yourself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://bittrance.github.io/extending-our-tekton-pipeline/deploy-striv-extended.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://bittrance.github.io/extending-our-tekton-pipeline/deploy-striv-run-2.yaml
</span></span></code></pre></div><p>At last, we can apply this pipeline run and get a successful test run:</p><p><img src=/extending-our-tekton-pipeline/deploy-striv-run-2.png alt="deploy-striv run successful" title="deploy-striv run successful"></p><h2 id=next-step>Next step</h2><p>We now have a complete testing pipeline. To make this a complete continuous delivery pipeline, it needs to build and deploy the Docker container that is the main artifact. However, that should happen only from some branches, so first we need to set up a trigger so that GitHub informs us when and what changes are pushed to the striv repository. More on this in the next blog post.</p></div><div class=post-footer></div></article></main></body></html>